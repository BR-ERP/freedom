package org.freedom.util.resource;

import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;

/**
 * Pool de recursos genérico.
 * Serve para o armazenamento qualquer tipo de objeto.
 * @author: Robson Sanchez/Setpoint Informática Ltda.
 */
public abstract class AbstractResourcePool implements Runnable {

   /** Número inicial de conexões. */
   public static final int INI_CON = 10;

   /** availableRes - Recursos disponíveis. */
   private transient Map availableRes , inUseResources;

   /** maxResources - Número máximo de recursos que podem ser instânciados. */
   private transient int maxResources;

   /** waitIfMaxedOut - Indica se deve aguardar a liberação de recursos. */
   private transient boolean waitIfMaxedOut;

   /** error - Guarda a última exceção ocorrida ( método @see run() ). */
   private transient ResourceException error = null;

   /** Log4j da classe. */
   private static final Logger LOGGER = createLogger();

   // Extensões têm que implementar estes três métodos
   /**
    * Criador de recursos.
    * @throws ResourceException Exceção na criação de recurso.
    * @return Retorna um recurso.
    */
   public abstract ResourceKey createResource() throws ResourceException;

   /**
    * Verifica se um recurso é válido.
    * @param resource Recebe um recurso para avaliação.
    * @return Indica se o recurso é válido.
    */
   public abstract boolean isResourceValid(ResourceKey resource);

   /**
    * Fecha um determinado recurso.
    * @param resource Recurso que devera ser fechado.
    */
   public abstract void closeResource(ResourceKey resource);

   /**
    * Construtor da classe sem parânetros.
    */
   public AbstractResourcePool() {
      this(INI_CON, // por padrão, um máximo de 10 recursos no pool
            false); // não espera pelo recurso se maximizado
   }

   /**
    * Construtor da classe com parâmetros iniciais.
    * @param max Número máximo de recursos inicializados.
    * @param waitIfMaxOut Flag que indica se deverá esperar
    * um conexão ser liberada.
    */
   public AbstractResourcePool(final int max, final boolean waitIfMaxOut) {
      availableRes = new HashMap();
      inUseResources = new HashMap();
      this.maxResources = max;
      this.waitIfMaxedOut = waitIfMaxOut;
   }

   /**
    * Retorna um vetor com os recursos disponíveis.
    * @return HashMap com os recursos disponíveis.
    */
   protected final Map getAvailableRes() {
      return this.availableRes;
   }

   /**
    * Valida e retorna os recursos a partir dos parâmetros.
    * @param sessionID Sessão chave.
    * @param key Chave secundária.
    * @param password Senha.
    * @return Retorna um recurso.
    * @throws ResourceException Caso aconteça uma exceção aborta
    * com um ResourceException.
    */
   public final ResourceKey getResource(final String sessionID,
         final String key, final String password) throws ResourceException {
      return getResource(sessionID, key, password, 0);
   }

   /**
    * Retorna um recurso a partir dos parâmetros chave.
    * @param sessionID Sessão chave.
    * @param key Chave secundária.
    * @param password Senha.
    * @param timeout Tempo de espera pelo recurso.
    * @return Retorna um recurso.
    * @throws ResourceException Caso aconteça uma exceção aborta
    * com um ResourceException.
    */
   public final synchronized ResourceKey getResource(
      final String sessionID, final String key, final String password,
      final long timeout) throws ResourceException {
      ResourceKey resource = getFirstAvailableResource(sessionID + key);
      if (resource == null) { // Sem recursos disponíveis
         if (countResources() < maxResources) {
            waitForAvailableResource();
            resource = getFirstResource(sessionID, key, password);
         } else if (waitIfMaxedOut) { // limite máximo de recursos atingido
            try {
               wait(timeout);
            } catch (InterruptedException ex) {
               LOGGER.error(ex);
            }
            resource = getFirstResource(sessionID, key, password);
         } else {
            throw new ResourceException(
               "Número máximo de recursos atingidos. Tente mais tarde.");
         }
      }
      if (resource != null) {
         resource.setSessionID(sessionID);
         inUseResources.put(resource.getHashKey(), resource);
      }
      return resource;
   }

   /** Cria a instância do Log4j da classe.
    ** @return Retorna a instância de log para a classe.
    */
   private static Logger createLogger() {
      return Logger.getLogger("org.freedom.util.resource.AbstractResourcePool");
   }

   /**
    * Recicla o recurso para reutilização.
    * @param resource Recebe o recurso para a reciclagem.
    */
   public final synchronized void recycleResource(final ResourceKey resource) {
      inUseResources.remove(resource.getHashKey());
      availableRes.put(resource.getHashKey(), resource);
      notifyAll(); // notifica threads em espera de con disponíveis
   }

   /**
    * Desliga o Pool fechando todos os recursos.
    */
   public final void shutdown() {
      closeResources(availableRes);
      closeResources(inUseResources);
      availableRes.clear();
      inUseResources.clear();
   }

   /**
    * Inicia o Thread do Pool de recursos.
    */
   public final synchronized void run() {
      ResourceKey resource;
      ResourceException errorrun = null;
      try {
         resource = createResource(); // criação de subclasses
         if (resource != null) {
            availableRes.put(resource.getHashKey(), resource);
         }
      } catch (ResourceException ex) {
         errorrun = ex; // armazena a exceção
      }
      error = errorrun;
      notifyAll(); // notifica threas em espera
   }

   /**
    * Retorna o primeiro recurso disponível.
    * @param key Chave para buscar o recursos.
    * @return Retorna o recurso disponível.
    */
   private ResourceKey getFirstAvailableResource(final String key) {
      ResourceKey resource = null;

      if (availableRes.size() > 0) {
         resource = getFirstResource(key);
      }
      if ((resource != null) && (!isResourceValid(resource))) {
         resource = getFirstAvailableResource(key); // tenta novamente
      }
      return resource;
   }

   /**
    * Aguarda a liberação de um recurso.
    * @throws ResourceException Caso aconteça uma exceção aborta
    * o método através de um ResourceException.
    */
   private void waitForAvailableResource() throws ResourceException {
      final Thread thread = new Thread(this);
      thread.start(); // thread cria um recurso: veja run()
      try {
         wait(); // espera que un novo recurso seja criado
         // ou que um recurso seja reciclado
      } catch (InterruptedException ex) {
         LOGGER.error(ex);
      }
      if (error != null) { // exceção pega em run()
         throw error;
      } // reemite exceção pega em run()
   }

   /**
    * Fecha um lista de recursos.
    * @param resources Recebe a lista de recursos a fechar.
    */
   private void closeResources(final Map resources) {
      resources.clear();
   }

   /**
    * Consulta o número de recursos totais.
    * @return Retorna o número de recursos.
    */
   private int countResources() {
      return availableRes.size() + inUseResources.size();
   }

   /**
    * Encontra e retorna o primeiro recurso encontrado com a chave.
    * @param key Chave para a pesquisa do recurso.
    * @return Retorna o recurso encontrado.
    */
   private ResourceKey getFirstResource(final String key) {
      String keypesq = null;
      if (key == null) {
         keypesq = "";
      } else {
         keypesq = key;
      }
      final ResourceKey resource = (ResourceKey)
         availableRes.get(keypesq);
      if (resource != null) {
         availableRes.remove(key);
      }
      return resource;
   }

   /**
    * Retorna o primerio recurso econtrado através de uma chave composta.
    * @param sessionID ID da Sessão chave.
    * @param key Chave secundária.
    * @param password Senha para validação.
    * @return Retorna o recurso encontrado.
    */
   private ResourceKey getFirstResource(final String sessionID,
         final String key, final String password) {
      final String keypesq = (key == null ? "" : key);
      final ResourceKey resource = (ResourceKey)
         availableRes.get(sessionID + keypesq);
      if (resource != null && resource.getPassword().equals(password)) {
            availableRes.remove(resource.getHashKey());
      }
      return resource;
   }

   /**
    * Retorna um recurso a partir de uma sessão chave.
    * @param sessionID ID da Sessão chave para a pesquisa.
    * @return Retorna o recurso encontrado.
    */
   public final ResourceKey getResourceSession(final String sessionID) {
      final ResourceKey resource = (ResourceKey)
         inUseResources.get(sessionID);
      return resource;
   }
}
